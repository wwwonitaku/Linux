name: AHiHi -> OCR Hardsub

on:
  workflow_dispatch:
    inputs:
      type: { description: "Type", required: true }
      slug: { description: "Slug", required: true }
      ss: { description: "Season", required: true }
      ep: { description: "Ep", required: true }
      hid: { description: "Hid", required: true }
      token: { description: 'Token', required: true }
      page: { description: 'Page', required: true }
      account: { description: 'AID', required: true }
      hyd:  { description: 'HYD', required: true }
      key: { description: 'Key', required: true }

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v3

      - name: Setup Environment
        run: |
          sudo apt update
          sudo apt install -y ffmpeg curl jq unzip fontconfig python3 python3-pip openjdk-17-jre-headless libgomp1
          python3 -m pip install --upgrade pip
          python3 -m pip install webvtt-py requests edge-tts opencv-python paddleocr paddlepaddle

      - name: Setup Subtitle Font (Oswald)
        run: |
          mkdir -p fonts
          curl -L https://github.com/wwwonitaku/Linux/raw/main/Oswald.zip -o Oswald.zip
          unzip -o Oswald.zip -d fonts
          fc-cache -f fonts

      - name: Get download & subtitle link (English)
        run: |
          HID="${{ github.event.inputs.hid }}"
          EP="${{ github.event.inputs.ep }}"
          RESP1=$(curl -s "https://hihianimeapi.onrender.com/api/v1/episodes/a-${HID}")
          LINK_EP=$(echo "$RESP1" | jq -r ".data[] | select(.episodeNumber == ($EP|tonumber)) | .id")
          RESP2=$(curl -s "https://hihianimeapi.onrender.com/api/v1/stream?type=sub&server=hd-2&id=${LINK_EP}")
          # Link video gốc (để render cuối cùng cho đẹp, không bị dính sub cũ)
          echo "LINK_DL=$(echo "$RESP2" | jq -r '.data.link.file')" >> $GITHUB_ENV
          # Link sub Anh (để lấy mốc thời gian)
          echo "LINK_SUB=$(echo "$RESP2" | jq -r '.data.tracks[]? | select(.label=="English") | .file' | head -n1)" >> $GITHUB_ENV

      - name: Download Videos & English Sub
        run: |
          # 1. Tải video RAW (để dùng làm nền render cuối cùng)
          ffmpeg -y -i "$LINK_DL" -c copy -bsf:a aac_adtstoasc raw_video.mp4
          
          # 2. Tải sub Anh (skeleton)
          curl -L "$LINK_SUB" -o eng.vtt
          
          # 3. Tải video HARDSUB (để OCR lấy chữ Việt)
          mkdir -p tools
          curl -L -o tools/abyss-dl.jar https://github.com/abdlhay/AbyssVideoDownloader/releases/latest/download/abyss-dl.jar
          java -jar tools/abyss-dl.jar "${{ github.event.inputs.hyd }}" h -o "hardsub.mp4"

      - name: OCR Extraction (Get Vi text from Hardsub)
        run: |
          python3 <<'EOF'
          import cv2
          import webvtt
          from paddleocr import PaddleOCR
          import os

          # Khởi tạo OCR tiếng Việt
          ocr = PaddleOCR(use_angle_cls=True, lang='vi', use_gpu=False, show_log=False)
          
          eng_vtt = webvtt.read("eng.vtt")
          cap = cv2.VideoCapture("hardsub.mp4")
          
          vi_vtt = webvtt.WebVTT()
          
          print(f"Bắt đầu OCR {len(eng_vtt)} câu thoại...")

          def time_to_ms(time_str):
              h, m, s = time_str.split(':')
              return int(float(h)*3600000 + float(m)*60000 + float(s)*1000)

          for i, caption in enumerate(eng_vtt):
              # Nhảy đến giữa mốc thời gian của sub Anh
              start_ms = time_to_ms(caption.start)
              end_ms = time_to_ms(caption.end)
              mid_ms = (start_ms + end_ms) / 2
              
              cap.set(cv2.CAP_PROP_POS_MSEC, mid_ms)
              ret, frame = cap.read()
              
              extracted_text = ""
              if ret:
                  # Cắt 1/4 dưới màn hình (vùng chứa sub) để tăng độ chính xác
                  h, w, _ = frame.shape
                  crop = frame[int(h*0.7):h, :]
                  
                  result = ocr.ocr(crop, cls=True)
                  if result and result[0]:
                      # Ghép các dòng chữ nhận diện được
                      extracted_text = " ".join([line[1][0] for line in result[0]])
              
              if not extracted_text.strip():
                  extracted_text = "..." # Backup nếu không quét được
                  
              print(f"[{i}] {caption.start} -> {extracted_text}")
              vi_vtt.captions.append(webvtt.Caption(caption.start, caption.end, extracted_text))

          vi_vtt.save("vi_extracted.vtt")
          cap.release()
          EOF

      - name: TTS Processing (From Extracted Sub)
        run: |
          python3 <<'EOF'
          import webvtt, os, asyncio, edge_tts, subprocess, re

          async def generate_tts(text, out, semaphore):
              async with semaphore:
                  try:
                      # Dọn dẹp text cho TTS
                      text = re.sub(r'\s+', ' ', text).strip()
                      if not text: text = "..."
                      tts = edge_tts.Communicate(text, voice="vi-VN-HoaiMyNeural", rate="+28%")
                      await tts.save(out)
                  except:
                      subprocess.run(["ffmpeg","-y","-f","lavfi","-i","anullsrc=r=24000:cl=mono","-t","0.1",out])

          async def main():
              vtt = webvtt.read("vi_extracted.vtt")
              os.makedirs("chunks", exist_ok=True)
              semaphore = asyncio.Semaphore(5)
              tasks = [generate_tts(c.text, f"chunks/c_{i}.mp3", semaphore) for i, c in enumerate(vtt)]
              await asyncio.gather(*tasks)
              
              with open("count.txt", "w") as f: f.write(str(len(vtt)))
              # Lưu lại bản vi.vtt cuối cùng để build filter
              vtt.save("vi.vtt")

          asyncio.run(main())
          EOF

      - name: Build Filter
        run: |
          python3 <<EOF
          import webvtt
          vtt = webvtt.read("vi.vtt")
          with open("master_filter.txt","w") as f:
              for i,c in enumerate(vtt):
                  h,m,s = c.start.replace(',','.').split(':')
                  ms = int(float(h)*3600000 + float(m)*60000 + float(s)*1000) + 200
                  f.write(f"[{i+1}:a]adelay={ms}|{ms}[a{i}];")
              f.write("".join(f"[a{i}]" for i in range(len(vtt))))
              f.write(f"amix=inputs={len(vtt)}:normalize=0,volume=3.0[tts];")
              f.write("[0:a]volume=0.90[bg];[bg][tts]amix=inputs=2[out_audio];")
              f.write("[0:v]subtitles=vi.vtt:fontsdir=fonts:force_style='FontName=Oswald,PrimaryColour=&H00FFFF&,FontSize=33,Outline=0.4,Shadow=0.4'[out_video]")
          EOF

      - name: Render & HLS
        run: |
          NAME="${{ github.event.inputs.type }}-${{ github.event.inputs.slug }}-${{ github.event.inputs.ss }}-${{ github.event.inputs.ep }}"
          COUNT=$(cat count.txt)
          INPUTS="-i raw_video.mp4"
          for ((i=0; i<COUNT; i++)); do
            INPUTS="$INPUTS -i chunks/c_$i.mp3"
          done

          ffmpeg -y $INPUTS -filter_complex_script master_filter.txt \
            -map "[out_video]" -map "[out_audio]" \
            -c:v libx264 -crf 23 -preset medium -tune animation \
            -pix_fmt yuv420p \
            -r 24 -g 120 -c:a aac -b:a 128k final.mp4

          mkdir -p output
          ffmpeg -i final.mp4 -c copy -f hls \
            -hls_time 5 -hls_list_size 0 -start_number 10001 -hls_playlist_type vod \
            -hls_segment_type fmp4 \
            -hls_fmp4_init_filename "${NAME}-index.png" \
            -hls_segment_filename "output/${NAME}-index%d.png" \
            "output/${NAME}.m3u8"
          ffmpeg -y -i final.mp4 -ss 00:04:15 -vframes 1 -q:v 2 output/${NAME}-index0.png
          cp vi.vtt output/

      - name: Deploy to Cloudflare Pages
        uses: cloudflare/pages-action@v1
        with:
          apiToken: ${{ github.event.inputs.token }}
          accountId: ${{ github.event.inputs.account }}
          projectName: ${{ github.event.inputs.page }}
          directory: ./output
          branch: ${{ github.event.inputs.type }}-${{ github.event.inputs.slug }}-${{ github.event.inputs.ss }}-${{ github.event.inputs.ep }}
