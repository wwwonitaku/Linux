name: AHiHi

on:
  workflow_dispatch:
    inputs:
      type: { description: "Type", required: true }
      slug: { description: "Slug", required: true }
      ss: { description: "Season", required: true }
      ep: { description: "Ep", required: true }
      hid: { description: "Hid", required: true }
      token: { description: 'Token', required: true }
      page: { description: 'Page', required: true }
      account: { description: 'AID', required: true }
      key: { description: 'Key', required: true }

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v3

      - name: Setup Environment
        run: |
          sudo apt update
          sudo apt install -y ffmpeg curl jq unzip fontconfig python3 python3-pip
          python3 -m pip install --upgrade pip
          python3 -m pip install webvtt-py requests edge-tts

      - name: Setup Subtitle Font (Oswald)
        run: |
          mkdir -p fonts
          curl -L https://github.com/wwwonitaku/Linux/raw/main/Oswald.zip -o Oswald.zip
          unzip -o Oswald.zip -d fonts
          fc-cache -f fonts

      - name: Get download & subtitle link
        run: |
          HID="${{ github.event.inputs.hid }}"
          EP="${{ github.event.inputs.ep }}"
          RESP1=$(curl -s "https://hihianimeapi.onrender.com/api/v1/episodes/a-${HID}")
          LINK_EP=$(echo "$RESP1" | jq -r ".data[] | select(.episodeNumber == ($EP|tonumber)) | .id")
          RESP2=$(curl -s "https://hihianimeapi.onrender.com/api/v1/stream?type=sub&server=hd-2&id=${LINK_EP}")
          echo "LINK_DL=$(echo "$RESP2" | jq -r '.data.link.file')" >> $GITHUB_ENV
          echo "LINK_SUB=$(echo "$RESP2" | jq -r '.data.tracks[]? | select(.label=="English") | .file' | head -n1)" >> $GITHUB_ENV

      - name: Download Video & Subtitle
        run: |
          ffmpeg -y -i "$LINK_DL" -c copy -bsf:a aac_adtstoasc raw_video.mp4
          curl -L "$LINK_SUB" -o eng.vtt
          
          # Check nếu đã có sub Việt trên server
          FILE_NAME="${{ github.event.inputs.type }}-${{ github.event.inputs.slug }}-${{ github.event.inputs.ss }}-${{ github.event.inputs.ep }}.vtt"
          CHECK_URL="https://anisrc.top/vtt/${FILE_NAME}"
          
          if curl --output /dev/null --silent --head --fail "$CHECK_URL"; then
            echo "[INFO] Pre-translated sub found!"
            curl -L "$CHECK_URL" -o vi_downloaded.vtt
            echo "HAS_VI_SUB=true" >> $GITHUB_ENV
          else
            echo "HAS_VI_SUB=false" >> $GITHUB_ENV
          fi

      - name: AI Translate + TTS (Fixed Stability)
        env:
          GEMINI_API_KEY: ${{ github.event.inputs.key }}
          HAS_VI_SUB: ${{ env.HAS_VI_SUB }}
        run: |
          python3 <<'EOF'
          import webvtt, os, time, re, requests, asyncio, edge_tts, subprocess

          API_KEY = os.environ['GEMINI_API_KEY']
          HAS_VI_SUB = os.environ.get('HAS_VI_SUB') == 'true'
          MAX_CONCURRENT_TTS = 5 

          def get_model():
              try:
                  res = requests.get(f"https://generativelanguage.googleapis.com/v1/models?key={API_KEY}").json()
                  for t in ['gemini-2.5-flash','gemini-2.0-flash','gemini-1.5-flash']:
                      for m in res.get('models', []):
                          if t in m['name']: return m['name']
                  return res['models'][0]['name']
              except: return "gemini-1.5-flash"

          def safe_text(text, max_len=450):
              if not text: return "..."
              text = re.sub(r'\s+', ' ', text).strip()
              return text if len(text) <= max_len else text[:max_len] + "..."

          def normalize_for_tts(text):
              # Chuyển toàn bộ văn bản thành chữ thường để tránh lỗi TTS khi gặp chữ viết hoa
              text = text.lower()
              text = re.sub(r'\s+', ' ', text).strip()
              text = text.replace(",", ", ").replace(".", ". ").replace("?", "? ").replace("!", "! ")
              text = text.replace("…", " ... ").replace("—", " ... ")
              if not text.endswith((".", "!", "?", "...")): text += "."
              return text

          async def generate_tts(text, out, idx, semaphore):
              async with semaphore:
                  try:
                      tts_text = normalize_for_tts(text)
                      tts = edge_tts.Communicate(tts_text, voice="vi-VN-NamMinhNeural", rate="+28%")
                      await tts.save(out)
                      if not os.path.exists(out) or os.path.getsize(out) < 100: raise Exception("Fail")
                      print(f"[TTS OK] #{idx}")
                  except:
                      print(f"[TTS RETRY] #{idx}")
                      await asyncio.sleep(2)
                      try:
                          tts = edge_tts.Communicate(normalize_for_tts(text), voice="vi-VN-NamMinhNeural", rate="+28%")
                          await tts.save(out)
                      except:
                          subprocess.run(["ffmpeg","-y","-f","lavfi","-i","anullsrc=r=24000:cl=mono","-t","0.1",out], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)

          async def main():
            # LUỒNG CHÍNH: QUYẾT ĐỊNH DÙNG SUB CÓ SẴN HAY DỊCH
            if HAS_VI_SUB and os.path.exists("vi_downloaded.vtt"):
                print("[INFO] Using existing Vietnamese subtitle file.")
                final_vtt = webvtt.read("vi_downloaded.vtt")
                all_vi_texts = [c.text for c in final_vtt]
            else:
                print("[INFO] No VI sub found or translation required. Starting AI Translation...")
                model = get_model()
                eng_vtt = webvtt.read("eng.vtt")
                total = len(eng_vtt)
                all_vi_texts = [None] * total
                
                for i in range(0, total, 60):
                    batch = eng_vtt[i:i+60]
                    expected_ids = set(range(i, i+len(batch)))
                    for attempt in range(1, 3):
                        prompt = "Bạn là biên dịch viên Anime chuyên nghiệp. Giữ định dạng ID: Nội dung.\n\n"
                        prompt += "\n".join(f"{i+j}: {c.text.replace(chr(10),' ')}" for j, c in enumerate(batch))
                        try:
                            url = f"https://generativelanguage.googleapis.com/v1beta/{model}:generateContent?key={API_KEY}"
                            r = requests.post(url, json={
                                "contents":[{"parts":[{"text":prompt}]}],
                                "safetySettings": [{"category":c,"threshold":"BLOCK_NONE"} for c in ["HARM_CATEGORY_HARASSMENT","HARM_CATEGORY_HATE_SPEECH","HARM_CATEGORY_SEXUALLY_EXPLICIT","HARM_CATEGORY_DANGEROUS_CONTENT"]]
                            }, timeout=250)
                            data = r.json()
                            txt = data["candidates"][0]["content"]["parts"][0]["text"]
                            txt = re.sub(r'```.*?```', '', txt, flags=re.DOTALL)
                            for line in txt.splitlines():
                                m = re.match(r'^(\d+):\s*(.+)', line.strip())
                                if m and int(m.group(1)) in expected_ids:
                                    all_vi_texts[int(m.group(1))] = m.group(2)
                            if not (expected_ids - set([idx for idx, val in enumerate(all_vi_texts) if val is not None and idx in expected_ids])): break
                        except: pass
                        time.sleep(2)
                    
                    if any(all_vi_texts[idx] is None for idx in expected_ids):
                        print(f"[FATAL] Translation failed at batch {i}")
                        raise SystemExit(1)
                
                # Tạo đối tượng final_vtt từ kết quả dịch (giữ timeline bản Anh)
                final_vtt = webvtt.WebVTT()
                for i, c in enumerate(eng_vtt):
                    final_vtt.captions.append(webvtt.Caption(c.start, c.end, all_vi_texts[i]))

            # ===== TIẾN HÀNH TTS TỪ FILE FINAL_VTT =====
            # Tại đây final_vtt luôn có timeline chuẩn của nó
            os.makedirs("chunks", exist_ok=True)
            vi_vtt_to_save = webvtt.WebVTT()
            semaphore = asyncio.Semaphore(MAX_CONCURRENT_TTS)
            tasks = []
        
            for i, c in enumerate(final_vtt):
                txt = safe_text(c.text)
                vi_vtt_to_save.captions.append(webvtt.Caption(c.start, c.end, txt))
                tasks.append(generate_tts(txt, f"chunks/c_{i}.mp3", i, semaphore))
        
            await asyncio.gather(*tasks)
            vi_vtt_to_save.save("vi.vtt")
        
            with open("count.txt", "w") as f:
                f.write(str(len(final_vtt)))
            print("[DONE] Subtitle Processing + TTS completed")

          asyncio.run(main())
          EOF

      - name: Build Filter
        run: |
          python3 <<EOF
          import webvtt
          vtt = webvtt.read("vi.vtt")
          with open("master_filter.txt","w") as f:
              for i,c in enumerate(vtt):
                  h,m,s = c.start.replace(',','.').split(':')
                  ms = int(float(h)*3600000 + float(m)*60000 + float(s)*1000) + 200
                  f.write(f"[{i+1}:a]adelay={ms}|{ms}[a{i}];")
              f.write("".join(f"[a{i}]" for i in range(len(vtt))))
              f.write(f"amix=inputs={len(vtt)}:normalize=0,volume=3.0[tts];")
              f.write("[0:a]volume=0.90[bg];[bg][tts]amix=inputs=2[out_audio];")
              f.write("[0:v]subtitles=vi.vtt:fontsdir=fonts:force_style='FontName=Oswald,PrimaryColour=&H00FFFF&,FontSize=33,Outline=0.4,Shadow=0.4'[out_video]")
          EOF

      - name: Render & HLS
        run: |
          NAME="${{ github.event.inputs.type }}-${{ github.event.inputs.slug }}-${{ github.event.inputs.ss }}-${{ github.event.inputs.ep }}"
          COUNT=$(cat count.txt)
          INPUTS="-i raw_video.mp4"
          for ((i=0; i<COUNT; i++)); do
            INPUTS="$INPUTS -i chunks/c_$i.mp3"
          done

          ffmpeg -y $INPUTS -filter_complex_script master_filter.txt \
            -map "[out_video]" -map "[out_audio]" \
            -c:v libx264 -crf 21 -preset medium -tune animation \
            -pix_fmt yuv420p \
            -r 24 -g 120 -keyint_min 120 -sc_threshold 0 \
            -c:a aac -b:a 128k final.mp4

          mkdir -p output
          ffmpeg -i final.mp4 -c copy -f hls \
            -hls_time 5 -hls_list_size 0 -start_number 10001 -hls_playlist_type vod \
            -hls_segment_type fmp4 \
            -hls_fmp4_init_filename "${NAME}-index.png" \
            -hls_segment_filename "output/${NAME}-index%d.png" \
            "output/${NAME}.m3u8"
          ffmpeg -y -i raw_video.mp4 -ss 00:03:15 -vf "select=gt(scene\,0.35),scale=-1:720" -vframes 1 -q:v 4 output/${NAME}-index.jpg
          cp vi.vtt output/

      - name: Deploy to Cloudflare Pages
        uses: cloudflare/pages-action@v1
        with:
          apiToken: ${{ github.event.inputs.token }}
          accountId: ${{ github.event.inputs.account }}
          projectName: ${{ github.event.inputs.page }}
          directory: ./output
          branch: ${{ github.event.inputs.type }}-${{ github.event.inputs.slug }}-${{ github.event.inputs.ss }}-${{ github.event.inputs.ep }}
