name: AHiHi -> CF (Audio Sync)

on:
  workflow_dispatch:
    inputs:
      slug: { required: true }
      token: { required: true }
      page: { required: true }
      account: { required: true }
      link_video:
        description: "Original video link"
        required: true
      link_audio_video:
        description: "Narration video ID"
        required: true

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Setup Java
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: '21'

      - name: Setup Python
        run: |
          sudo apt update
          sudo apt install -y ffmpeg curl git jq unzip python3 python3-pip
          python3 -m pip install --upgrade pip
          python3 -m pip install numpy scipy librosa soundfile

      - name: Download abyss-dl.jar
        run: |
          mkdir -p tools
          curl -L -o tools/abyss-dl.jar \
            https://github.com/abdlhay/AbyssVideoDownloader/releases/latest/download/abyss-dl.jar

      - name: Download original video
        run: |
          ffmpeg -y -i "${{ github.event.inputs.link_video }}" \
            -c copy -bsf:a aac_adtstoasc original.mp4

      - name: Download narration video (abyss-dl)
        run: |
          java -jar tools/abyss-dl.jar \
            "${{ github.event.inputs.link_audio_video }}" l -o narration.mp4

      - name: Extract audio
        run: |
          ffmpeg -y -i original.mp4  -ac 1 -ar 16000 original.wav
          ffmpeg -y -i narration.mp4 -ac 1 -ar 16000 narration.wav

      - name: Align audio & build final track
        run: |
          python3 <<'EOF'
          import librosa, numpy as np, soundfile as sf
          from scipy.signal import correlate

          SR = 16000
          WIN_SEC = 5     # Phân tích từng đoạn 5 giây
          STEP_SEC = 2    # Nhảy bước 2 giây để đảm bảo độ mịn
          
          def log(msg):
              print(f"[DEBUG] {msg}")

          # 1. LOAD & PRE-PROCESS
          log("Đang tải dữ liệu âm thanh...")
          y_o, _ = librosa.load("original.wav", sr=SR)
          y_n, _ = librosa.load("narration.wav", sr=SR)
          
          dur_o = len(y_o)/SR
          dur_n = len(y_n)/SR
          log(f"Thời lượng Gốc: {dur_o:.2f}s | Thuyết minh: {dur_n:.2f}s")

          # Trích xuất đặc trưng (Mel-spectrogram) để so sánh cấu trúc âm thanh
          def get_env(y):
              # Dùng biên độ tổng quát để tìm nhịp điệu (envelope)
              return librosa.resample(np.abs(y), orig_sr=SR, target_sr=200)

          ENV_SR = 200
          env_o = get_env(y_o)
          env_n = get_env(y_n)

          # 2. TÌM ĐIỂM KHỚP ĐẦU VÀ CUỐI (GLOBAL ALIGNMENT)
          log("Đang quét tìm điểm neo tổng thể...")
          # Thử khớp 20 giây đầu của narration vào 60 giây đầu của original
          sample_len = 20 * ENV_SR
          if len(env_n) > sample_len and len(env_o) > sample_len:
              corr_start = correlate(env_o[:60*ENV_SR], env_n[:sample_len], mode='valid')
              start_offset = np.argmax(corr_start) / ENV_SR
              log(f"Độ khớp điểm đầu dự kiến: {start_offset:.2f}s (Narration bắt đầu tại giây này trong Video Gốc)")
          else:
              start_offset = 0

          # 3. PHÂN TÍCH ĐA ĐIỂM (MULTI-ANCHOR SCANNING)
          log("Bắt đầu quét đa điểm để xử lý cắt ghép...")
          anchors = []
          win_size = WIN_SEC * ENV_SR
          step_size = STEP_SEC * ENV_SR

          last_o_idx = int(start_offset * ENV_SR)
          
          for i in range(0, len(env_n) - win_size, step_size):
              chunk = env_n[i : i + win_size]
              # Tìm trong phạm vi hẹp quanh vị trí dự kiến (+/- 20s) để tránh lặp lại
              search_min = max(0, last_o_idx - 5 * ENV_SR)
              search_max = min(len(env_o), last_o_idx + 25 * ENV_SR)
              
              if search_max - search_min < win_size: continue
              
              search_area = env_o[search_min : search_max]
              corr = correlate(search_area, chunk, mode='valid')
              best_local_idx = np.argmax(corr)
              
              current_o_idx = search_min + best_local_idx
              
              # Chỉ chấp nhận nếu thời gian trôi về phía trước (Chống lặp)
              if current_o_idx >= last_o_idx:
                  anchors.append((i / ENV_SR, current_o_idx / ENV_SR))
                  last_o_idx = current_o_idx

          log(f"Tìm thấy {len(anchors)} điểm neo hợp lệ.")

          # 4. TỔNG HỢP AUDIO (CONSTRUCTION)
          log("Đang xây dựng luồng Audio cuối cùng...")
          final_audio = y_o.copy()
          
          matched_count = 0
          for n_time, o_time in anchors:
              n_idx = int(n_time * SR)
              o_idx = int(o_time * SR)
              length = int(STEP_SEC * SR)
              
              if o_idx + length <= len(y_o) and n_idx + length <= len(y_n):
                  # Thay thế âm thanh gốc bằng thuyết minh tại các điểm khớp
                  final_audio[o_idx : o_idx + length] = y_n[n_idx : n_idx + length]
                  matched_count += 1

          # Tính độ bao phủ thành công
          coverage = (matched_count * STEP_SEC) / dur_n * 100
          log(f"Kết quả xử lý: Khớp thành công {coverage:.1f}% thời lượng thuyết minh.")
          if coverage < 50:
              log("CẢNH BÁO: Độ khớp thấp, có thể hai video có nội dung quá khác biệt.")

          sf.write("final_audio.wav", final_audio, SR)
          log("Hoàn tất ghi file final_audio.wav")
          EOF

      - name: Mux final video
        run: |
          OUT="${{ github.event.inputs.slug }}.mp4"
          ffmpeg -y \
            -i original.mp4 \
            -i final_audio.wav \
            -map 0:v -map 1:a \
            -c:v copy -c:a aac -b:a 128k \
            "$OUT"

      - name: Convert to HLS
        run: |
          NAME="${{ github.event.inputs.slug }}"
          mkdir -p output
          ffmpeg -i "${NAME}.mp4" -c copy -f hls \
            -hls_time 5 \
            -hls_list_size 0 \
            -start_number 10001 \
            -hls_playlist_type vod \
            -hls_segment_type fmp4 \
            -hls_fmp4_init_filename "${NAME}-index.png" \
            -hls_segment_filename "output/${NAME}-index%d.png" \
            "output/${NAME}.m3u8"

      - name: Deploy to Cloudflare Pages
        uses: cloudflare/pages-action@v1
        with:
          apiToken: ${{ github.event.inputs.token }}
          accountId: ${{ github.event.inputs.account }}
          projectName: ${{ github.event.inputs.page }}
          directory: ./output
          branch: ${{ github.event.inputs.slug }}
